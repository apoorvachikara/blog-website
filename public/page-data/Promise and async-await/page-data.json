{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/Promise and async-await/",
    "result": {"data":{"site":{"siteMetadata":{"title":"One Stop for JS full-stack"}},"markdownRemark":{"id":"9df759c5-14bb-5efb-a31a-4352664baeb2","excerpt":"Introduction Promise is an object that represents the state of any async operation we perform in our code using it. Once it reaches to one of its state we get…","html":"<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/f904b4e45ec9fd7fa38943055f286ab3/a2510/promises.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 41.77215189873418%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAIABQDASIAAhEBAxEB/8QAFwABAAMAAAAAAAAAAAAAAAAAAAECBf/EABcBAAMBAAAAAAAAAAAAAAAAAAABAwX/2gAMAwEAAhADEAAAAdGxnVkI/8QAFhABAQEAAAAAAAAAAAAAAAAAIQAQ/9oACAEBAAEFAmc//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAEP/aAAgBAQAGPwJ//8QAGBAAAgMAAAAAAAAAAAAAAAAAAAEhMUH/2gAIAQEAAT8hc9KCP//aAAwDAQACAAMAAAAQAC//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAVEQEBAAAAAAAAAAAAAAAAAAAQEf/aAAgBAgEBPxCn/8QAGRAAAgMBAAAAAAAAAAAAAAAAETEAAWFR/9oACAEBAAE/EKJsDk4vXCFFz//Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"imagenode\" title=\"imagenode\" src=\"/static/f904b4e45ec9fd7fa38943055f286ab3/828fb/promises.jpg\" srcset=\"/static/f904b4e45ec9fd7fa38943055f286ab3/ff44c/promises.jpg 158w,\n/static/f904b4e45ec9fd7fa38943055f286ab3/a6688/promises.jpg 315w,\n/static/f904b4e45ec9fd7fa38943055f286ab3/828fb/promises.jpg 630w,\n/static/f904b4e45ec9fd7fa38943055f286ab3/0ede0/promises.jpg 945w,\n/static/f904b4e45ec9fd7fa38943055f286ab3/a2510/promises.jpg 1000w\" sizes=\"(max-width: 630px) 100vw, 630px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<h3>Introduction</h3>\n<p>Promise is an object that represents the state of any async operation we perform in our code using it. Once it reaches to one of its state we get the value. We might be already using the promises, but it is always great to see them again what’s new with them.</p>\n<h2>Definition</h2>\n<p>In simple terms, it is an object on which we attach the callbacks instead of passing it in the function. It only produces single values in the future and it is successful or failed.</p>\n<p>We have been using promises now almost every where.</p>\n<h2>States</h2>\n<p>Promises have three states Pending, fulfilled and rejected. It must be in one state out of these three. We can methods on promise prototype to check if it is rejected or fulfilled. <code class=\"language-text\">then</code> method is used to check the values returned from promise and <code class=\"language-text\">catch</code> method is chainable that catches any error when promise is in rejected state.</p>\n<h2>Usage</h2>\n<p>Some of you might have already used the promises, you can skip this part may be. The below code snippet creates a promise and how to consume it.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function promise () {\n    return Promise.resolve('Hello World');\n}\n\nconst main = () => {\n    // access data in the data variable\n    promise().then((data) => {\n       console.log(data);\n    }).catch((e) => {\n        // access any errors in this block with e variable\n        console.error(e);\n    }).finally(() =>{\n        console.log('I will be called every time');\n    })\n} \n\nmain();</code></pre></div>\n<p>There are three methods on promise that are used to see the state of the promise - <code class=\"language-text\">then</code>, <code class=\"language-text\">catch</code> and <code class=\"language-text\">finally</code>. <code class=\"language-text\">Then</code> is used to get the results successfully from the promise, <code class=\"language-text\">catch</code> is used to get the errors in the promise and <code class=\"language-text\">finally</code> is used to called whether promise is resolved or rejected.</p>\n<h2>When and Why we use them?</h2>\n<p>Earlier, we used callbacks to make any asynchronous events completion. As soon as they are completed we called them.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const main = (cb, a, b,time) => {\n    setTimeout(() => {\n        cb(a, b);\n    }, time)\n}\n\nmain((a, b) => {\n     console.log(a + b); //7\n}, 3, 4, 1000)</code></pre></div>\n<p>Now, the issues come when we have nested call backs and there is any error. Promises make life easy when you use them.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">\n// callback hell example\nfunction first(args, function() {\n  secondFunction(args, function() {\n    thirdFunction(args, function() {\n      // And so on…\n    });\n  });\n});\n</code></pre></div>\n<h2>How to make a simple synchronous code async with promise?</h2>\n<p>Why I am adding this because I have seen a lot of new comers asked this question. How to make a sync code async in nature? The below code snippet will help you to make any sync code asynchronous. Some people say it an anti-pattern promise creation.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const main = () => {\n    return new Promise((resolve, reject) => {\n         if (true) {\n             //here put any success data you want to return\n             resolve('data');\n         } else {\n             reject('error');\n         }\n    })\n}\n\nmain().then((data) => {\n    console.log(data);\n}).catch((e) => {\n    console.error(e);\n});</code></pre></div>\n<h2>Why do we use async-await if we have promises?</h2>\n<p>Async-await is a syntactic sugar on then/catch. The underlying process is the same as that of promises, it uses then and catch.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const main = () => {\n    return Promise.resolve('Hello World');\n}\n\nasync function getData() {\n    try{\n        const data = await main();\n        console.log(data);\n    } catch(e) {\n        console.log(e);\n    }\n    \n\ngetData();</code></pre></div>\n<p>Advantages it makes the code much cleaner. However, there is no change in the underlying implementation. How JS is interpreting the above code is similar when you write using the then/catch operators.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const main = () => {\n    return Promise.resolve('Hello World');\n}\n\nasync function getData() {\n    main().then(data => {\n        console.log(data);\n    }).catch(console.log);\n}\n\ngetData();   </code></pre></div>\n<h2>Interview questions</h2>\n<ol>\n<li>Does promise or async-await blocks the main thread?</li>\n</ol>\n<p>No, it is a myth. It doesn’t block the main thread instead push things on microqueue in the event loop and once the async task is completed. The callbacks are pushed to the stack again for execution.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">async function main() {\n    try {\n         const res = await (an API call);\n         console.log(res);\n    } catch(e) {\n        console.log(e);\n    }\n}\nmain();</code></pre></div>\n<p>Whenever we put await, it stops the execution of the subsequent code. This is how JS will call the await on won’t block the main thread.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function main() {\n   (an api call).then((res)=>{\n       console.log(res);\n   }).catch(e => {\n       console.log(e);\n   })\n}</code></pre></div>\n<ol start=\"2\">\n<li>what is the o/p of below code?</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const wait = time => new Promise(res => setTimeout(() => res(), time));\n// delay of 200ms\nwait(200) // called after 200ms\n.then(() => new Promise(res => res('foo')))\n.then(a => a) \n.then(b => console.log(b)) // foo\n.then(() => null)\n.then(c => console.log(c)) // null\n.then(() => {throw new Error('foo');})\n.then(\nd => console.log(`d: ${ d }`),\ne => console.log(e)) // reason rejection\n.then(f => console.log(`f: ${ f }`)) // f: undefined\n.catch(e => console.log(e)) \n.then(() => { throw new Error('bar'); })\n.then(g => console.log(`g: ${ g }`))\n.catch(h => console.log(h)); // Error: bar</code></pre></div>\n<p>The wait method will return after 200ms. In the first then, it will return <code class=\"language-text\">foo</code> to the next then handler. It will keep returning until <code class=\"language-text\">console.log(b)</code> - foo. It next then <code class=\"language-text\">null</code> is returned to next then handler and print <code class=\"language-text\">null</code>. Now, the next handler will throw error and the very next handler(then) will print the error message in reason rejection.</p>\n<p>So, instead of calling catch it passing the error to next then handler reason callback. After this next then is called with <code class=\"language-text\">console.log(</code>f: ${ f }<code class=\"language-text\">)</code>. Catch block won’t be called as there are no errors and then we throw the error and will be caught in the last catch.</p>\n<ol start=\"3\">\n<li>How to make custom a promise such that it never rejects?</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const setPromise = () => {\n    return Promise.reject({statusCode: 400});\n}\n\nasync function promiseNeverRejects(asyncTask) {\n        try {\n            const res = await asyncTask(); \n            return res;\n        } catch(e) {\n            return e.statusCode ? `Error: status code ${e.statusCode}`: `Error: e ${e.message}`;\n        }\n}\n\nfunction main() {\n    promiseNeverRejects(setPromise).then((d) => {\n        console.log(`then: ${d}`); // then: Error: status code 400\n    }).catch(e => {\n        console.log(`catch: ${e}`);\n    })\n}</code></pre></div>\n<p>Note: More methods and details coming soon on promises in Part 2.</p>","frontmatter":{"title":"Promises and async-await in Javascript Part 1","date":"April 20, 2022","description":"Why do we need promises in javascript? How does it help us to make your code async and able to control the flow easily? Understand the promise states and know when to use and how to make any code async in nature."}},"previous":{"fields":{"slug":"/Javascript useful Object methods - Part I/"},"frontmatter":{"title":"Javascript Object methods - Part 1"}},"next":null},"pageContext":{"id":"9df759c5-14bb-5efb-a31a-4352664baeb2","previousPostId":"4403d5bf-0dee-5ea4-a9cb-a04ebb49a317","nextPostId":null}},
    "staticQueryHashes": ["2841359383","3257411868"]}