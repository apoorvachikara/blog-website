{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/JS an async or sync language.../",
    "result": {"data":{"site":{"siteMetadata":{"title":"One Stop for JS full-stack"}},"markdownRemark":{"id":"e8239a98-ea12-5819-9ea9-4b3b34b1880d","excerpt":"Introduction If you are reading this blog to know JS is an async or sync language, you are at the right place. I’m pretty sure after reading this blog, you will…","html":"<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/fe61655ec37e6fb8b68691b06df7afa1/5bb8b/async.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 54.43037974683544%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAACLklEQVQoz5VRaW/TQBT0//8LSMAXhFAjUUQLDW1FRdvcd+KjceJr4/jI5bups7uDEkctReIDTxq9t4dmnmaEPM+x3W6hqhM8PKhQVRWbIARjDLvdDpTSojOGKIogywqmmg5FVrAJAnDO9+8MAHzfFwXOD/N/FC/A2UGUc+z7gWS1WklCnOboTzaodA00RQe1AUF3vEKQ5M8UMy/CbcdCtU9QH9hoyz56ig/Gn78UhMulJCSPO4xJiubAQkd20RhYkPQQ6ZYjTROEwQbeKkVzNENHJLiqKTgpN3B+O4RkzDCdu5A0k5meD8/3JSHNMii6jgmZQdYMqIRA0jRESVpIs9eWkOUaZ7/ucHLxAx/Pywe8/3zGqtIYc9eVhChJ0BiJaAxHqPb6qA9HqHT7WIdR4RjnrwjXSQbN89Abj9F9UNEUZXTHE0ZWm4LwKadw1zmMeQjdjmA6EYiXIc7oMYCjh20D9x0d1Z6FtuhgNFn8qfMSSvq4Q1cNcV2b4qah47Iyxl3PgR+8hDJfxKgNZmiJNm5aU5zeDFCuKVBtD6a/wMR2mOktig23T090HYY0iBO6DCIaxPHhvL8H55Qxtl/1Gas4pt/uK/TDl6/0XemUvi2d0jefSruf3QHMmT0S4izDdb2Nq3oTF3dVXFYb+H5bxfLo4d8VZVto3hKSYUE2CSTdhGLNMA9juL6vCRYhLcOy2rpltcz9fAQhpGXb9j/huW4Bz2s5jtN0HWcoimLpN+hoKQDtsUOXAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"imagenode\" title=\"imagenode\" src=\"/static/fe61655ec37e6fb8b68691b06df7afa1/f058b/async.png\" srcset=\"/static/fe61655ec37e6fb8b68691b06df7afa1/c26ae/async.png 158w,\n/static/fe61655ec37e6fb8b68691b06df7afa1/6bdcf/async.png 315w,\n/static/fe61655ec37e6fb8b68691b06df7afa1/f058b/async.png 630w,\n/static/fe61655ec37e6fb8b68691b06df7afa1/5bb8b/async.png 749w\" sizes=\"(max-width: 630px) 100vw, 630px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<h2>Introduction</h2>\n<p>If you are reading this blog to know JS is an async or sync language, you are at the right place. I’m pretty sure after reading this blog, you will remember it your whole life about it. I’ve seen even the experienced developers might get it wrong because of the modern Javascript syntax.</p>\n<p>Let us first understand what is synchronous or asynchronous means.</p>\n<h3>Synchronous</h3>\n<p>Synchronous meaning when the code is executed, it is done in line by line fashion. It means second line will only be executed once the first line is successfully executed. I will be writing a series of blog how Javsascript works and event loop and all other working parts soon.</p>\n<p>Let’s take an example how sync code is executed:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const arr = [1, 2, 3, 4];\narr.push(5);\nconsole.log(arr) // [1, 2, 3, 4, 5]</code></pre></div>\n<h4>Flow</h4>\n<p>Step 1: <code class=\"language-text\">const arr = [1, 2, 3, 4];</code>  will be executed first and assign values to the <code class=\"language-text\">arr</code>.</p>\n<p>Step 2: <code class=\"language-text\">arr.push(5)</code> will be executed second and push value to the <code class=\"language-text\">arr</code>.</p>\n<p>Step 3: print on the console.</p>\n<p>All these three statement will be executed squentially or one by one. I am not adding techincal details here how JS executes them behind the scene, but soon add in a series of blog.</p>\n<h3>Asynchronous</h3>\n<p>Asynchronous meaning when the code is executed immediately and yeilds response in near future or some point in time ahead of execution. It can notify the caller using callback, promises or an event based paradigm. These days most of the API in JS are async based and thats why it feels like JS is async language now.</p>\n<p>We can see below how async code is executed in JS:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const prom = () => {\n    return new Promise((res, rej) => {\n        setTimeout(() => (res('Hello World asybc')), 1000);\n    });\n}\nconst main = async () => {\n  try {\n      const res = await prom();\n      console.log(res);\n  } catch (e) {\n      console.log(e);\n  }\n}\n\nmain(); // 'Hello World async' after altest 1 sec\nconsole.log('Hello World sync') // 'Hello World sync' called immediately </code></pre></div>\n<h4>Flow</h4>\n<p>We can see there are two functions, one is <code class=\"language-text\">main</code> and other one is <code class=\"language-text\">prom</code>(returns immediately but resolved or reject later in time).</p>\n<p>Step 1: <code class=\"language-text\">main()</code> function starts to call the function definition.</p>\n<p>Step 2: we execute <code class=\"language-text\">prom()</code> function, JS knows it has to wait on this line to make sure we receive the value from prom call.</p>\n<p>Step 3: In this case, the promise will be returned immediately, but the <code class=\"language-text\">res</code> callback will be called after atlest <code class=\"language-text\">1 sec</code>.</p>\n<p>Step 4: <code class=\"language-text\">console.log</code> will be just called after the <code class=\"language-text\">main()</code> as it won’t wait for the main to retun the result.</p>\n<p>I am pretty sure, you might not be following all this at this time if you are new to async programming. But this is how async programming works and it is great for JS as it is single threaded in nature and improves the User experience or both server and front-end experience.</p>\n<h2>Interview Question</h2>\n<ol>\n<li>What will be the o/p of the code?</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let state = 'ON';\nlet count = 0;\nwhile (state !== 'OFF') {\n   count += 1; \n   console.log(count);\n   setTimeout((state = 'OFF'), 1000)\n}</code></pre></div>\n<p>It keeps the counter up and running because JS is sync language. How does it happen? Let’s know about it.</p>\n<p>Step 1: <code class=\"language-text\">state</code> sets to ‘ON’.</p>\n<p>Step 2: <code class=\"language-text\">count</code> sets to ‘0’.</p>\n<p>Step 3: <code class=\"language-text\">while</code> loop pushed to the stack and we start to execute the first line and keep checking the condition.</p>\n<p>Step 4: count is updated to new value.</p>\n<p>Step 5: We logged the value of the count to the console.</p>\n<p>Step 6: we call the <code class=\"language-text\">setTimeout</code> web api and it is pushed on the stack and moved to the event loop.</p>\n<p>Step 7: Now the partial step 3 to step 5 will be executed continously without updating the status and why is that?</p>\n<p>It is because JS has to first finish the all execution on stack and then check all the cbs from the event loop and in this case it will never finish the stack operation and there will be an error <code class=\"language-text\">ERR_OUT_OF_MEMORY </code> or running on Node.js will be different.</p>\n<ol start=\"2\">\n<li>How to correct the above code?</li>\n</ol>\n<p>To make the above code correct you need to make sure that you check the condition on main thread only.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let state = 'ON';\nlet count = 0;\nconst currentDate = new Date().getTime();\nwhile (state === 'ON') {\n   count += 1; \n   console.log(count);\n\n   if ((new Date().getTime()) - currentDate > 1000) {\n       console.log((new Date().getTime()) - currentDate > 1000);\n       state = 'OFF';\n   } \n}\n\nconsole.log('I am on main thread too....Don\\'t block me');</code></pre></div>\n<p>Main thread consist of stack and once the stack is completely exhasuted JS engine checks the eventloop callback queue to push it to stage for their processing. And in the first question it will never going to happen because of forever while loop.</p>\n<p>However, we made the changes to second question to make sure why you should desgin your code in such a way that it won’t block main thread.</p>\n<p><strong>Note: If you find any information incorrect or want to update something that you know. Please chekc my github repo for the blog and make contribution to it.</strong></p>","frontmatter":{"title":"Is JS an async or sync language?","date":"December 20, 2021","description":"Understanding is javascript an async or sync language. It seems using promises and other webAPI like setTimeout, setInterval etc. proves that JS is async language?"}},"previous":{"fields":{"slug":"/Autoboxing In Js/"},"frontmatter":{"title":"AutoBoxing in Javascript"}},"next":{"fields":{"slug":"/Javascript arrays methods/"},"frontmatter":{"title":"Javascript Useful Array Methods"}}},"pageContext":{"id":"e8239a98-ea12-5819-9ea9-4b3b34b1880d","previousPostId":"7d6c3e8b-400e-5c73-be15-52a3b3332735","nextPostId":"ece601da-9422-5302-9787-545f107144f9"}},
    "staticQueryHashes": ["2841359383","3257411868"]}