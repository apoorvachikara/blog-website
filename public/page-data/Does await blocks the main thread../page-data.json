{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/Does await blocks the main thread../",
    "result": {"data":{"site":{"siteMetadata":{"title":"One Stop for JS full-stack"}},"markdownRemark":{"id":"48df420b-8a44-5662-80e3-6a498ab7573d","excerpt":"Introduction async/await These days, the websites are becoming more interactive. It has become increasingly important to do cpu-intensive operations like…","html":"<h3>Introduction async/await</h3>\n<p>These days, the websites are becoming more interactive. It has become increasingly important to do cpu-intensive operations like encryption, fectching large data from APIs by making external calls, etc. We have different things to handle distinct operations - encryption can be handled on web workers, APIs calls can be handled asynchronously (there are others things to cover, will do that in subsequent blogs).</p>\n<p>As Javascript is single-threaded programming language, we won’t discuss how it handle all the operations. We will discuss about async/await. It is a syntactic sugar on promises. A lot of developers are using async/await without knowing the underlying process of how they actually works. I have been seeing a lot of question on stackoverflow realting to their usage and does they actually block the main thread?</p>\n<p>This is quiet strange we use await to make the function synchronous(really!!) i.e we can control the flow or can hold the flow of execution where we use the await keyword provided that async should be placed for JS interperter(<strong>later version of JS does allow await keyword usage without async i.e at the top level</strong>);</p>\n<h3>When to use?</h3>\n<p>Async/await uses promises under the hood and when we should use promises? If there is any async operations that suceeds or fails in near future. Earlier we uses callbacks and they created the callback hell when nesting them.</p>\n<p>So, we started to use promises that can be cascased using then/catch. However, some developers still prefer to write async code with synchronous style and <em><strong>ECMAScript 2016(ES7)</strong></em> introduced <em><strong>async functions</strong></em> and <em><strong>await keyword</strong></em> to make working easier with promises.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// run this code in the broswer\n// see what is the o/p and why?\n\n\nconst asycnBlock2 = () => {\n  return new Promise((res, rej) => {\n         setTimeout(() =>{\n               res('It will be resolved');\n         }, 1000)\n  });\n}\n\nconst asycnBlock3 = () => {\n  return new Promise((res, rej) => {\n     setTimeout(() =>{\n               res('It will be rejected');\n         }, 2000);\n\n  })\n}\n\nconst asycnBlock1 = async () => {\n    try {\n       const result = await asycnBlock2();\n       const result2 = await asycnBlock3();\n       console.log(`It won't be printed until await is resolved`);\n       console.log(`Result: ${result}, Result2: ${result2}`);\n    } catch (e) {\n       console.log(`This will be printed on any rejection`)\n       console.log(`Error is ${e.message}`);\n    }\n}\n\n\nawait asycnBlock1();\n\nconsole.log('Blocking the main thread?');</code></pre></div>\n<h3>Working</h3>\n<p>How does it actually work? So, I am adding a simple async/await code and try to explain how javascripts executes it.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const wait = (time) => new Promise((res, rej) => setTimeout(() => res(`I have waited ${time} before executing this statement`),time));\nconst main = async () => {\n    try {\n        const result = await wait(4000);\n        console.log(result);\n    } catch (e) { console.log(e) };\n}\n\nmain();</code></pre></div>\n<p>When we run the above code, we can see the results won’t be printed until wait resolves or rejects (for this specific example if resolves). Javascript basically interprets it like a then and catchable series of statements.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const wait = (time) => new Promise((res, rej) => setTimeout(() => res(`I have waited ${time} before executing this statement`),time));\nconst main = async () => {\n    return new Promise((res, rej) => {\n          wait().then((result) =>  {\n            console.log(result);\n            res(result)\n            }).catch(e =>  console.log(e));\n    });\n}\n\nmain();</code></pre></div>\n<p>The above code o/p the exact same results, this is how Javascript reads the above async/await code and execute it.</p>\n<h3>Myths?</h3>\n<p>Does it blocks the main thread? As Javascript is single threaded language and anything that blocks the main thread will hamnper the user experience and if running on Node.js will impact the exection of business logic. So, how does it actually handles it without blocking the main thread?</p>\n<p>From the above code, we have seen how async/await is just a wrapper or syntactic sugar on the promises. It very well explains how Javascript pushes things on the event loop to execute it.</p>\n<h3>Interview Questions</h3>\n<ol>\n<li></li>\n</ol>","frontmatter":{"title":"Does async/await blocks the main thread?","date":"January 01, 2022","description":"Learn Autoboxing to understand how primitives type access methods and properties."}},"previous":{"fields":{"slug":"/Autoboxing In Js/"},"frontmatter":{"title":"AutoBoxing in Javascript"}},"next":{"fields":{"slug":"/Javascript arrays methods/"},"frontmatter":{"title":"Javascript Array Methods"}}},"pageContext":{"id":"48df420b-8a44-5662-80e3-6a498ab7573d","previousPostId":"7d6c3e8b-400e-5c73-be15-52a3b3332735","nextPostId":"ece601da-9422-5302-9787-545f107144f9"}},
    "staticQueryHashes": ["2841359383","3257411868"]}