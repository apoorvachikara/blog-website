{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/Autoboxing In Js/",
    "result": {"data":{"site":{"siteMetadata":{"title":"One Stop for JS full-stack"}},"markdownRemark":{"id":"7d6c3e8b-400e-5c73-be15-52a3b3332735","excerpt":"Autoboxing in Javascript is not a new topic, but most of us have not heard or learned about it. Have you ever wondered why primitive types are able to access…","html":"<p>Autoboxing in Javascript is not a new topic, but most of us have not heard or learned about it. Have you ever wondered why primitive types are able to access their associated object properties or methods?</p>\n<p>If you want to know about types, I have a very descriptive blog <a href=\"/Types%20in%20JS/\">here</a>. You can excel on <strong>types in 2 minutes</strong> in Javascript.</p>\n<h3>Primitives Types</h3>\n<p>Creating a string and checking its length will be an easy task, but how string primitive type is able to access the property on the String object?</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const foo = \"bar\";\nconsole.log(foo.length); // 3</code></pre></div>\n<p><strong>Primitive types</strong> don’t have any properties and methods on them. From the above code, it seems the primitives do have methods on it, but this is not the case here. It’s magic and we can it an autoboxing feature in JS.</p>\n<p>Whenever we call any method or property on primitive types, the primitives are wrapped into their associative objects(i.e built-in objects). In the above case, it is a string. So, <strong>autoboxing</strong> helps connect primitive types to their built-in objects and provides methods and properties to access on it.</p>\n<p>There are a few cases, I would like to showcase first then we will discuss them.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">S.no.</th>\n<th align=\"left\">code</th>\n<th align=\"center\">output</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">1</td>\n<td align=\"left\">String(‘hello’)</td>\n<td align=\"center\">‘hello’</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">String(‘hello’) == new String(‘hello’)</td>\n<td align=\"center\">true</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">String(‘hello’) === new String(‘hello’)</td>\n<td align=\"center\">false</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">new String(‘hello’) === new String(‘hello’)</td>\n<td align=\"center\">false</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">new String(‘hello’) == new String(‘hello’)</td>\n<td align=\"center\">false</td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\">String(‘hello’) instanceof String</td>\n<td align=\"center\">false</td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td align=\"left\">new String(‘hello’) instanceof String</td>\n<td align=\"center\">true</td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li>\n<p>It is a string primitive and when you console it, it returns the value which is being passed.</p>\n</li>\n<li>\n<p>This is a comparison operation b/w string primitive and string object(it is created when call using new). As this will only compare the values, the returned o/p is true. But if you check the <code class=\"language-text\">new String('hello world')</code> output, What do you see in the console?</p>\n</li>\n<li>\n<p>Here we are checking the values with type and definitely it will return false as types are different. One is <code class=\"language-text\">string</code> and the other is <code class=\"language-text\">object</code>.</p>\n</li>\n<li>\n<p>Why it is <code class=\"language-text\">false</code>? We are comparing objects and two different objects can’t be the same even if they have the same values, Why? Because they are compared by reference(i.e their memory address and it will be different for every object), this is the reason for <code class=\"language-text\">false</code>.</p>\n</li>\n<li>\n<p>Again, it has the same explanation as above. The object holds the memory address as the value in it which refers to the exact values it holds in it(Know about pointers? if not check <a href=\"https://stackoverflow.com/questions/518000/is-javascript-a-pass-by-reference-or-pass-by-value-language#:~:text=It&#x27;s%20always%20pass%20by%20value,persist%20outside%20of%20the%20function.\">this</a>).</p>\n</li>\n<li>\n<p>As the string is a primitive type, it is not an instance of the String class. However to access property autoboxing is done.</p>\n</li>\n<li>\n<p>Since it is created using the <code class=\"language-text\">new</code> operator it is an instance of the String class.</p>\n</li>\n</ol>\n<h3>When and Why use primitives?</h3>\n<p>Generally, we should use primitives when we are using strings, numbers or any primitive types. It is efficient and why is that?</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const testStr = \"Hello world!\";\nconsole.log(testStr.valueOf());</code></pre></div>\n<p>The above string is primitive and it doesn’t have any method and properties attached to it. So, the value of <code class=\"language-text\">testStr</code> will be accessed with a much higher speed. In the next statement, what happens when we fetch the values of length properties? Since <code class=\"language-text\">testStr</code> is not an instance of string, JS will auto-box it by checking the type and aligning with the same wrapper to it.</p>\n<p>JS calls like this <code class=\"language-text\">testStr.valueOf().prototype.toString.call = [object String]</code>, it is done back and forth based on the methods we are calling on primitive type. These days the JS engines are pretty advanced and it is not necessary that the above-mentioned process will be held every time.</p>\n<h3>Interview Question</h3>\n<ol>\n<li>Difference b/w String() and new String()?</li>\n</ol>\n<p>You can’t add properties to string primitive, however you can do that when you create it using new.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let testStr = 'Hello World';\ntestStr = \"Hello World Updated\"; // new string will be constructed they are immutable\n\n// with new String()\nlet testStr = new String('Hello World');\ntestStr = \"Hello World Updated\"; // updates the same object testStr</code></pre></div>\n<ol start=\"2\">\n<li>How can we make the below statement true?</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">String('hello') === new String('hello');</code></pre></div>\n<p>We know that this will return false, but how can we actually access the values of the string object? You can use the <code class=\"language-text\">valueOf</code> method and it will return the values of the object be it String, Number or boolean.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">String('hello') === new String('hello').valueOf();</code></pre></div>","frontmatter":{"title":"AutoBoxing in Javascript","date":"December 20, 2021","description":"Learn Autoboxing to understand how primitives type access methods and properties."}},"previous":{"fields":{"slug":"/Types in JS/"},"frontmatter":{"title":"Types in Javascript"}},"next":{"fields":{"slug":"/Javascript arrays methods/"},"frontmatter":{"title":"Javascript Useful Array Methods"}}},"pageContext":{"id":"7d6c3e8b-400e-5c73-be15-52a3b3332735","previousPostId":"a440ba58-f43e-5273-9859-e6b943573786","nextPostId":"ece601da-9422-5302-9787-545f107144f9"}},
    "staticQueryHashes": ["2841359383","3257411868"]}