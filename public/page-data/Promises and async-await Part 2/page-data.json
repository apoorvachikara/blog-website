{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/Promises and async-await Part 2/",
    "result": {"data":{"site":{"siteMetadata":{"title":"One Stop for JS full-stack"}},"markdownRemark":{"id":"1f469d3a-b223-5c0c-a445-24e10c8e6720","excerpt":"Introduction If you want to learn the basics about Promises check here. In the last blog, we understood about basics of promises when to use them, how to make a…","html":"<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/a0b66e3998d8d8ba5f4b864f95346aef/a2510/promises-part-2.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 41.77215189873418%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAIABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAIF/8QAFgEBAQEAAAAAAAAAAAAAAAAAAAMF/9oADAMBAAIQAxAAAAHRozqgf//EABYQAQEBAAAAAAAAAAAAAAAAACEAEP/aAAgBAQABBQJnP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABQQAQAAAAAAAAAAAAAAAAAAABD/2gAIAQEABj8Cf//EABkQAAMAAwAAAAAAAAAAAAAAAAABIRExQf/aAAgBAQABPyF33BoJw//aAAwDAQACAAMAAAAQg8//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAVEQEBAAAAAAAAAAAAAAAAAAAAEf/aAAgBAgEBPxCo/8QAGhAAAgMBAQAAAAAAAAAAAAAAAAERMWEhUf/aAAgBAQABPxBKX0w8b2xblJ//2Q=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"imagenode\" title=\"imagenode\" src=\"/static/a0b66e3998d8d8ba5f4b864f95346aef/828fb/promises-part-2.jpg\" srcset=\"/static/a0b66e3998d8d8ba5f4b864f95346aef/ff44c/promises-part-2.jpg 158w,\n/static/a0b66e3998d8d8ba5f4b864f95346aef/a6688/promises-part-2.jpg 315w,\n/static/a0b66e3998d8d8ba5f4b864f95346aef/828fb/promises-part-2.jpg 630w,\n/static/a0b66e3998d8d8ba5f4b864f95346aef/0ede0/promises-part-2.jpg 945w,\n/static/a0b66e3998d8d8ba5f4b864f95346aef/a2510/promises-part-2.jpg 1000w\" sizes=\"(max-width: 630px) 100vw, 630px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n<h3>Introduction</h3>\n<p>If you want to learn the basics about Promises <a href=\"/Promise%20and%20async-await/\">check here</a>. In the last blog, we understood about basics of promises when to use them, how to make a callback-based function return promise and how to use then/catch as the chainable operators.</p>\n<p>In this blog section, we will discuss different methods of promises. We will understand how and when to use them. Here is the list:</p>\n<p>— Promise.all()</p>\n<p>— Promise.allSettled()</p>\n<p>— Promise.any()</p>\n<p>— Promise.race()</p>\n<p>I am not including then/catch/finally as we have already discussed them.</p>\n<h4>Promise.all</h4>\n<p>One of methods developers use extensively for promises. As the name suggest <code class=\"language-text\">all</code> refers to all the promises passed to this function. It returns the single value as resolved or rejected.</p>\n<h5>Syntax</h5>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Promise.all([promise_1, promise_2 ..., promise_n])</code></pre></div>\n<h5>Example</h5>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Promise.all([1, 2, 3].map(el => {\n    return Promise.resolve().then(() => {\n      return el * 2;\n    })\n})).then(data => {\n  // data is an array \n  // you will get the results in same order as \n  // you specify them\n  console.log(data); // [2, 4, 6]\n})</code></pre></div>\n<h5>Description</h5>\n<p>You can take multiple promises in an array and pass this array to all method if all the promises are resolved you can get the data in the thenable method as payload (see in the above code).</p>\n<p>If one of the promises is rejected, all the promises will get rejected and you won’t get the expected results. Only those values will be given in the payload until it is not rejected.</p>\n<h5>Use case</h5>\n<p>If you have some promises and you want to only do something when all of them are successfully resolved.</p>\n<p>For example, if you want to bootstrap the application with some configuration needed for the app, you can use it to see all that configuration should be loaded first and then load the app (only for explanation purposes).</p>\n<h4>Promise.allSettled()</h4>\n<p>It is one of the methods you can use if you want to check  rejected and resolved promises together unlike Promise.all that won’t show any subsequent resolved promises if one of them is rejected.</p>\n<h5>Syntax</h5>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Promise.allSettled([1, 2, 3].map((el) => {\n      if (el === 2) return Promise.reject(el * 2);\n      return Promise.resolve(el* 2);\n})).then((data) => {\n    console.log(data); // o/p in below code\n})</code></pre></div>\n<p>It will return the o/p in same manner, but will include the status of it’s reason for rejection and if resolved value will be shared;</p>\n<p>O/P</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">0: {status: 'fulfilled', value: 2}\n1: {status: 'rejected', reason: 4}\n2: {status: 'fulfilled', value: 6}</code></pre></div>\n<h5>Description</h5>\n<p>You can pass the array to this method and it will return the array in form of result for every promise. It will include the status and reason/value based on promise status as shown above, but it will run for every promise in the array unlike <code class=\"language-text\">Promise.all</code>.</p>\n<h5>Use case</h5>\n<p>It is useful when you want to keep the code flow running even if some of the promises fail.</p>\n<p>For example, If you have Dashboard and there are multiple microservices for some parts like user deatils microservice, metrics microservice, some other modules microservices. So, you can use allSettled to atleast show the dashboard and reload the rejected services again in the view.</p>\n<p>This won’t hinder user experience in loading the UI view.</p>\n<h4>Promise.any()</h4>\n<p>It is useful when you need to start any process as soon as one of the promises is resolved or when all the promises are rejected with an AggregateError.</p>\n<h5>Syntax</h5>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Promise.any([1, 2, 3].map((el) => {\n      if (el === 2) return Promise.reject(el * 2);\n      return Promise.resolve(el* 2);\n})).then((data) => {\n    console.log(data); // 2\n})</code></pre></div>\n<h5>Description</h5>\n<p>In the above code, it will return the value of first resolved promise i.e even the prvious promises are rejected it will still return the first resolved promise.</p>\n<h5>Use case</h5>\n<p>Useful when you are only dependent on the first resolve of your promises.</p>\n<p>For example, You can use in the dasboard where you can show the data for any service once you receive the data and other can be placed to retry logic.</p>\n<h4>Promise.race()</h4>\n<p>It is useful as soon as one of the iterable promises is resolved or rejected i.e the first one in the array of promises that is fullfiled or rejected.</p>\n<h5>Syntax</h5>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const prom1 = new Promise((resolve, reject) => {\n  setTimeout(resolve, 500, 'one');\n});\n\nconst prom2 = new Promise((resolve, reject) => {\n  setTimeout(resolve, 100, 'two');\n});\n\nPromise.race([prom1, prom2]).then((value) => {\n  console.log(value); // prom2 will be resolved faster</code></pre></div>\n<h5>Description</h5>\n<p>In the above code, we passed two promises in the race method and <code class=\"language-text\">prom2</code> will be resolved first as it is called on the stack after atleast 100ms. The o/p will be the fastest resolved</p>\n<h5>Use case</h5>\n<p>It is useful when you want to check and load module in the application as soon as you received data to that particular module.</p>\n<h2>Interview Questions</h2>\n<ol>\n<li>Can we use async-await and then/catch together?</li>\n</ol>\n<p>No, we can’t use async/await is just syntactic sugar on then/catch. I have seen many people use them together, but we shouldn’t do it.</p>\n<p>Some developers do this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const prom = () =>  Promise.resolve('Hello World');\n// Node v16\n// high level await\nawait prom().then(console.log).catch(console.log);\n}</code></pre></div>\n<p>You don’t need to mix them, it behaves very differently as we expect. Instead, use the below pattern;</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const prom = () =>  Promise.resolve('Hello World');\n// Node v16\n// high level await\ntry {\n    const response = await prom();\n} catch(e) {\n    console.log(e);\n}\n\n// lower version of node\nfunction main() {\n   prom().then(data => {\n       console.log(data);\n   }).catch(e => {\n       console.log(e);\n   })\n}\n\nmain();</code></pre></div>\n<ol start=\"2\">\n<li>Should we use promise constructor to return the values?</li>\n</ol>\n<p>No, As you can’t leverage the promise chain if you use it. Check <a href=\"https://stackoverflow.com/questions/23803743/what-is-the-explicit-promise-construction-antipattern-and-how-do-i-avoid-it\">here</a>.</p>\n<p>You can simply use the async keyword with your function. It will automatically wrap the response in the promise and send it to the calling function.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function main() {\n    called().then((data) => {\n         console.log(data);\n    }).catch(console.error);\n}\n\nasync function called() {\n    return 'Hello World';\n}\n\nmain();</code></pre></div>\n<ol start=\"3\">\n<li>What is the o/p of below code?</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const  promises = [Promise.resolve('Hello World'), Promise.resolve('Hello World 2')];\nconst output = Promise.race(promises);\nconsole.log(output)\n})</code></pre></div>\n<p>The answer will be <code class=\"language-text\">Pending state</code> and why? Because of its asynchronous nature, you will see output as <code class=\"language-text\">pending state</code>. immediately logging the value of o/p won’t return anything as it has not updated yet.</p>\n<p>Once the stack is empty, it will push the resolved promises back to the stack and populate its values.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const  promises = [Promise.resolve('Hello World'), Promise.resolve('Hello World 2')];\nconst output = Promise.race(promises);\nconsole.log(output);\n\nsetTimeout(() => {\nconsole.log(output);\n}, 0)</code></pre></div>","frontmatter":{"title":"Promises and async-await in Javascript Part 2","date":"May 24, 2022","description":"In the last blog, we learn about promises and how do we use them. In this section, we will run more about promise methods. What are promises anti-pattern? How do we make things run in parallel using promises?"}},"previous":{"fields":{"slug":"/Promise and async-await/"},"frontmatter":{"title":"Promises and async-await in Javascript Part 1"}},"next":null},"pageContext":{"id":"1f469d3a-b223-5c0c-a445-24e10c8e6720","previousPostId":"9df759c5-14bb-5efb-a31a-4352664baeb2","nextPostId":null}},
    "staticQueryHashes": ["2841359383","3257411868"]}